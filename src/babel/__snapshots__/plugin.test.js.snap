// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`works together with @babel/plugin-transform-modules-commonjs 1`] = `
"\\"use strict\\";

var _reghex = require(\\"reghex\\");

var _node_expression = (0, _reghex._pattern)(1),
    _node_expression2 = (0, _reghex._pattern)(2);

const node = function _node(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (match = (0, _reghex._exec)(state, _node_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  if (match = (0, _reghex._exec)(state, _node_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return (0, _reghex.tag)(node, 'node');
};"
`;

exports[`works with local recursion 1`] = `
"import { tag, _exec, _substr, _pattern } from 'reghex';

const inner = function _inner(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (match = _substr(state, \\"inner\\")) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return tag(node, 'inner');
};

const node = function _node(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (match = inner(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return tag(node, 'node');
};"
`;

exports[`works with non-capturing groups 1`] = `
"import { _exec, _substr, _pattern, tag as _tag } from 'reghex';

var _node_expression = _pattern(1),
    _node_expression2 = _pattern(2),
    _node_expression3 = _pattern(3);

const node = function _node(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (match = _exec(state, _node_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var length_0 = node.length;

  alternation_1: {
    block_1: {
      var index_1 = state.index;

      if (match = _exec(state, _node_expression2)) {
        node.push(match);
      } else {
        node.length = length_0;
        state.index = index_1;
        break block_1;
      }

      break alternation_1;
    }

    loop_1: for (var iter_1 = 0; true; iter_1++) {
      var index_1 = state.index;

      if (!_exec(state, _node_expression3)) {
        if (iter_1) {
          state.index = index_1;
          break loop_1;
        }

        node.length = length_0;
        state.index = last_index;
        return;
      }
    }
  }

  return _tag(node, 'node');
};"
`;

exports[`works with standard features 1`] = `
"import { _exec, _substr, _pattern, tag as _tag } from \\"reghex\\";

var _node_expression = _pattern(1),
    _node_expression2 = _pattern(2),
    _node_expression3 = _pattern(3),
    _node_expression4 = _pattern(4),
    _node_expression5 = _pattern(5);

const node = function _node(state) {
  var last_index = state.index;
  var match,
      node = [];

  block_0: {
    var index_0 = state.index;

    loop_0: for (var iter_0 = 0; true; iter_0++) {
      var index_0 = state.index;

      if (match = _exec(state, _node_expression)) {
        node.push(match);
      } else {
        if (iter_0) {
          state.index = index_0;
          break loop_0;
        }

        state.index = index_0;
        break block_0;
      }
    }

    return _tag(node, 'node');
  }

  loop_0: for (var iter_0 = 0; true; iter_0++) {
    var index_0 = state.index;

    if (match = _exec(state, _node_expression2)) {
      node.push(match);
    } else {
      if (iter_0) {
        state.index = index_0;
        break loop_0;
      }

      state.index = last_index;
      return;
    }
  }

  loop_0: while (true) {
    var index_0 = state.index;
    var length_0 = node.length;

    if (match = _exec(state, _node_expression3)) {
      node.push(match);
    } else {
      node.length = length_0;
      state.index = index_0;
      break loop_0;
    }

    var index_2 = state.index;

    if (match = _exec(state, _node_expression4)) {
      node.push(match);
    } else {
      state.index = index_2;
    }

    if (match = _exec(state, _node_expression5)) {
      node.push(match);
    } else {
      node.length = length_0;
      state.index = index_0;
      break loop_0;
    }
  }

  return _tag(node, 'node');
};"
`;

exports[`works with transform functions 1`] = `
"import { _exec, _substr, _pattern, tag as _tag } from 'reghex';

var _inner_transform = x => x;

const first = function _inner(state) {
  var last_index = state.index;
  var match,
      node = [];
  return _inner_transform(_tag(node, 'inner'));
};

const transform = x => x;

const second = function _node(state) {
  var last_index = state.index;
  var match,
      node = [];
  return transform(_tag(node, 'node'));
};"
`;
