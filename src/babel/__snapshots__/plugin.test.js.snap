// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`works together with @babel/plugin-transform-modules-commonjs 1`] = `
"\\"use strict\\";

var _reghex = require(\\"reghex\\");

var _node_expression = (0, _reghex._pattern)(1),
    _node_expression2 = (0, _reghex._pattern)(2);

const node = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;

  if (match = (0, _reghex._exec)(state, _node_expression)) {
    node.push(match);
  } else {
    state.index = index_1;
    return;
  }

  if (match = (0, _reghex._exec)(state, _node_expression2)) {
    node.push(match);
  } else {
    state.index = index_1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works while only minifying 1`] = `
"import { match } from 'reghex/macro';
const node = match('node')([\\"\\", \\"+|\\", \\"+(\\", \\"(\\", \\"?\\", \\"))*\\"], 1, 2, 3, 4, 5);"
`;

exports[`works with local recursion 1`] = `
"import { match as m, tag, _exec, _pattern } from 'reghex';

const inner = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;

  if (match = _exec(state, \\"inner\\")) {
    node.push(match);
  } else {
    state.index = index_1;
    return;
  }

  node.tag = 'inner';
  return node;
};

const node = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;

  if (match = inner(state)) {
    node.push(match);
  } else {
    state.index = index_1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with non-capturing groups 1`] = `
"import { match, _exec, _pattern, tag as _tag } from 'reghex';

var _node_expression = _pattern(1),
    _node_expression2 = _pattern(2),
    _node_expression3 = _pattern(3);

const node = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;

  if (match = _exec(state, _node_expression)) {
    node.push(match);
  } else {
    state.index = index_1;
    return;
  }

  var length_2 = node.length;

  alternation_3: {
    block_3: {
      var index_3 = state.index;

      if (match = _exec(state, _node_expression2)) {
        node.push(match);
      } else {
        state.index = index_3;
        node.length = length_2;
        break block_3;
      }

      break alternation_3;
    }

    loop_3: for (var count_3 = 0; true; count_3++) {
      var index_3 = state.index;

      if (!_exec(state, _node_expression3)) {
        if (count_3) {
          state.index = index_3;
          break loop_3;
        } else {}

        state.index = index_1;
        node.length = length_2;
        return;
      }
    }
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with self-referential thuns 1`] = `
"import { match, tag, _exec, _pattern } from 'reghex';
const inner = m('inner')\`
      \${() => node}
    \`;
const node = m('node')\`
      \${inner}
    \`;"
`;

exports[`works with standard features 1`] = `
"import { match, _exec, _pattern, tag as _tag } from \\"reghex\\";

var _node_expression = _pattern(1),
    _node_expression2 = _pattern(2),
    _node_expression3 = _pattern(3),
    _node_expression4 = _pattern(4),
    _node_expression5 = _pattern(5);

const node = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;

  alternation_2: {
    block_2: {
      var index_2 = state.index;

      loop_2: for (var count_2 = 0; true; count_2++) {
        var index_2 = state.index;

        if (match = _exec(state, _node_expression)) {
          node.push(match);
        } else {
          if (count_2) {
            state.index = index_2;
            break loop_2;
          } else {}

          state.index = index_2;
          break block_2;
        }
      }

      break alternation_2;
    }

    loop_2: for (var count_2 = 0; true; count_2++) {
      var index_2 = state.index;

      if (match = _exec(state, _node_expression2)) {
        node.push(match);
      } else {
        if (count_2) {
          state.index = index_2;
          break loop_2;
        } else {}

        state.index = index_1;
        return;
      }
    }

    loop_2: while (true) {
      var index_2 = state.index;
      var length_2 = node.length;

      if (match = _exec(state, _node_expression3)) {
        node.push(match);
      } else {
        state.index = index_2;
        node.length = length_2;
        break loop_2;
      }

      var index_4 = state.index;

      if (match = _exec(state, _node_expression4)) {
        node.push(match);
      } else {
        state.index = index_4;
      }

      if (match = _exec(state, _node_expression5)) {
        node.push(match);
      } else {
        state.index = index_2;
        node.length = length_2;
        break loop_2;
      }
    }
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with transform functions 1`] = `
"import { match, _exec, _pattern, tag as _tag } from 'reghex';

var _inner_transform = x => x;

const first = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;
  node.tag = 'inner';
  return _inner_transform(node);
};

const transform = x => x;

const second = function (state) {
  var index_1 = state.index;
  var node = [];
  var match;
  node.tag = 'node';
  return transform(node);
};"
`;
