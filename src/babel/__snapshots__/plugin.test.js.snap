// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`works together with @babel/plugin-transform-modules-commonjs 1`] = `
"\\"use strict\\";

var _reghex = require(\\"reghex\\");

var _node_expression = _reghex.__private.pattern(1),
    _node_expression2 = _reghex.__private.pattern(2);

const node = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  if (x = _reghex.__private.exec(state, _node_expression)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  if (x = _reghex.__private.exec(state, _node_expression2)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works while only minifying 1`] = `
"import { match } from 'reghex/macro';
const node = match('node')([\\"\\", \\"+|\\", \\"+(\\", \\"(\\", \\"?\\", \\"))*\\"], 1, 2, 3, 4, 5);"
`;

exports[`works with local recursion 1`] = `
"import { match as m, tag, __private } from 'reghex';

var _inner_expression = __private.pattern(/inner/);

const inner = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  if (x = __private.exec(state, _inner_expression)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  node.tag = 'inner';
  return node;
};

const node = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  if (x = inner(state)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with non-capturing groups 1`] = `
"import { match, __private } from 'reghex';

var _node_expression = __private.pattern(1),
    _node_expression2 = __private.pattern(2),
    _node_expression3 = __private.pattern(3);

const node = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  if (x = __private.exec(state, _node_expression)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  var ln2 = node.length;

  alt_3: {
    block_3: {
      var y3 = state.y,
          x3 = state.x;

      if (x = __private.exec(state, _node_expression2)) {
        node.push(x);
      } else {
        state.y = y3;
        state.x = x3;
        node.length = ln2;
        break block_3;
      }

      break alt_3;
    }

    loop_3: for (var j3 = 0; 1; j3++) {
      var y3 = state.y,
          x3 = state.x;

      if (x = __private.exec(state, _node_expression3)) {} else {
        if (j3) {
          state.y = y3;
          state.x = x3;
          break loop_3;
        } else {}

        state.y = y1;
        state.x = x1;
        node.length = ln2;
        return;
      }
    }
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with self-referential thunks 1`] = `
"import { match, tag, __private } from 'reghex';

const inner = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  if (x = node(state)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  node.tag = 'inner';
  return node;
};

const node = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  if (x = inner(state)) {
    node.push(x);
  } else {
    state.y = y1;
    state.x = x1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with standard features 1`] = `
"import { match, __private } from \\"reghex\\";

var _node_expression = __private.pattern(1),
    _node_expression2 = __private.pattern(2),
    _node_expression3 = __private.pattern(3),
    _node_expression4 = __private.pattern(4),
    _node_expression5 = __private.pattern(5);

const node = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;

  alt_2: {
    block_2: {
      var y2 = state.y,
          x2 = state.x;

      loop_2: for (var j2 = 0; 1; j2++) {
        var y2 = state.y,
            x2 = state.x;

        if (x = __private.exec(state, _node_expression)) {
          node.push(x);
        } else {
          if (j2) {
            state.y = y2;
            state.x = x2;
            break loop_2;
          } else {}

          state.y = y2;
          state.x = x2;
          break block_2;
        }
      }

      break alt_2;
    }

    loop_2: for (var j2 = 0; 1; j2++) {
      var y2 = state.y,
          x2 = state.x;

      if (x = __private.exec(state, _node_expression2)) {
        node.push(x);
      } else {
        if (j2) {
          state.y = y2;
          state.x = x2;
          break loop_2;
        } else {}

        state.y = y1;
        state.x = x1;
        return;
      }
    }

    loop_2: for (;;) {
      var y2 = state.y,
          x2 = state.x;
      var ln2 = node.length;

      if (x = __private.exec(state, _node_expression3)) {
        node.push(x);
      } else {
        state.y = y2;
        state.x = x2;
        node.length = ln2;
        break loop_2;
      }

      var y4 = state.y,
          x4 = state.x;

      if (x = __private.exec(state, _node_expression4)) {
        node.push(x);
      } else {
        state.y = y4;
        state.x = x4;
      }

      if (x = __private.exec(state, _node_expression5)) {
        node.push(x);
      } else {
        state.y = y2;
        state.x = x2;
        node.length = ln2;
        break loop_2;
      }
    }
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with transform functions 1`] = `
"import { match, __private } from 'reghex';

var _inner_transform = x => x;

const first = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;
  node.tag = 'inner';
  return _inner_transform(node);
};

const transform = x => x;

const second = function (state) {
  var y1 = state.y,
      x1 = state.x;
  var node = [];
  var x;
  node.tag = 'node';
  return transform(node);
};"
`;
