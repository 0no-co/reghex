// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`works together with @babel/plugin-transform-modules-commonjs 1`] = `
"\\"use strict\\";

var _reghex = require(\\"reghex\\");

var _node_expression = (0, _reghex._pattern)(1),
    _node_expression2 = (0, _reghex._pattern)(2);

const node = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  if (x = (0, _reghex._exec)(state, _node_expression)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  if (x = (0, _reghex._exec)(state, _node_expression2)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works while only minifying 1`] = `
"import { match } from 'reghex/macro';
const node = match('node')([\\"\\", \\"+|\\", \\"+(\\", \\"(\\", \\"?\\", \\"))*\\"], 1, 2, 3, 4, 5);"
`;

exports[`works with local recursion 1`] = `
"import { match as m, tag, _exec, _pattern } from 'reghex';

var _inner_expression = _pattern(/inner/);

const inner = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  if (x = _exec(state, _inner_expression)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  node.tag = 'inner';
  return node;
};

const node = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  if (x = inner(state)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with non-capturing groups 1`] = `
"import { match, _exec, _pattern, tag as _tag } from 'reghex';

var _node_expression = _pattern(1),
    _node_expression2 = _pattern(2),
    _node_expression3 = _pattern(3);

const node = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  if (x = _exec(state, _node_expression)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  var ln2 = node.length;

  alt_3: {
    block_3: {
      var y3 = state.y;

      if (x = _exec(state, _node_expression2)) {
        node.push(x);
      } else {
        state.y = y3;
        node.length = ln2;
        break block_3;
      }

      break alt_3;
    }

    loop_3: for (var j3 = 0; 1; j3++) {
      var y3 = state.y;

      if (!_exec(state, _node_expression3)) {
        if (j3) {
          state.y = y3;
          break loop_3;
        } else {}

        state.y = y1;
        node.length = ln2;
        return;
      }
    }
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with self-referential thunks 1`] = `
"import { match, tag, _exec, _pattern } from 'reghex';

const inner = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  if (x = node(state)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  node.tag = 'inner';
  return node;
};

const node = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  if (x = inner(state)) {
    node.push(x);
  } else {
    state.y = y1;
    return;
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with standard features 1`] = `
"import { match, _exec, _pattern, tag as _tag } from \\"reghex\\";

var _node_expression = _pattern(1),
    _node_expression2 = _pattern(2),
    _node_expression3 = _pattern(3),
    _node_expression4 = _pattern(4),
    _node_expression5 = _pattern(5);

const node = function (state) {
  var y1 = state.y;
  var node = [];
  var x;

  alt_2: {
    block_2: {
      var y2 = state.y;

      loop_2: for (var j2 = 0; 1; j2++) {
        var y2 = state.y;

        if (x = _exec(state, _node_expression)) {
          node.push(x);
        } else {
          if (j2) {
            state.y = y2;
            break loop_2;
          } else {}

          state.y = y2;
          break block_2;
        }
      }

      break alt_2;
    }

    loop_2: for (var j2 = 0; 1; j2++) {
      var y2 = state.y;

      if (x = _exec(state, _node_expression2)) {
        node.push(x);
      } else {
        if (j2) {
          state.y = y2;
          break loop_2;
        } else {}

        state.y = y1;
        return;
      }
    }

    loop_2: for (;;) {
      var y2 = state.y;
      var ln2 = node.length;

      if (x = _exec(state, _node_expression3)) {
        node.push(x);
      } else {
        state.y = y2;
        node.length = ln2;
        break loop_2;
      }

      var y4 = state.y;

      if (x = _exec(state, _node_expression4)) {
        node.push(x);
      } else {
        state.y = y4;
      }

      if (x = _exec(state, _node_expression5)) {
        node.push(x);
      } else {
        state.y = y2;
        node.length = ln2;
        break loop_2;
      }
    }
  }

  node.tag = 'node';
  return node;
};"
`;

exports[`works with transform functions 1`] = `
"import { match, _exec, _pattern, tag as _tag } from 'reghex';

var _inner_transform = x => x;

const first = function (state) {
  var y1 = state.y;
  var node = [];
  var x;
  node.tag = 'inner';
  return _inner_transform(node);
};

const transform = x => x;

const second = function (state) {
  var y1 = state.y;
  var node = [];
  var x;
  node.tag = 'node';
  return transform(node);
};"
`;
